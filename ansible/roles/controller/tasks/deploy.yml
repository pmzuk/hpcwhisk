#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
---
# This role will install Controller in group 'controllers' in the environment
# inventory

- import_tasks: docker_login.yml

- name: get controller name and index
  set_fact:
    controller_name: "{{ name_prefix ~ host_group.index(inventory_hostname) }}"
    controller_index:
      "{{ (controller_index_base|int) + host_group.index(inventory_hostname) }}"

- name: "pull the {{ docker.image.tag }} image of controller"
  shell: "docker pull {{docker_registry}}{{ docker.image.prefix }}/controller:{{docker.image.tag}}"
  when: docker_registry != ""
  register: result
  until: (result.rc == 0)
  retries: "{{ docker.pull.retries }}"
  delay: "{{ docker.pull.delay }}"

- name: ensure controller log directory is created with permissions
  file:
    path: "{{ whisk_logs_dir }}/{{ controller_name }}"
    state: directory
    mode: 0777
  become: "{{ logs.dir.become }}"

# We need to create the file with proper permissions because the dir creation above
# does not result in a dir with full permissions in docker machine especially with macos mounts
- name: ensure controller log file is created with permissions
  file:
    path: "{{ whisk_logs_dir }}/{{ controller_name }}/{{ controller_name }}_logs.log"
    state: touch
    mode: 0777
  when: environment_type is defined and environment_type == "docker-machine"

- name: ensure controller config directory is created with permissions
  file:
    path: "{{ controller.confdir }}/{{ controller_name }}"
    state: directory
    mode: 0777
  become: "{{ controller.dir.become }}"

- name: copy jmxremote password file
  when: jmx.enabled
  template:
    src: "jmxremote.password.j2"
    dest: "{{ controller.confdir }}/{{ controller_name }}/jmxremote.password"
    mode: 0777

- name: copy jmxremote access file
  when: jmx.enabled
  template:
    src: "jmxremote.access.j2"
    dest: "{{ controller.confdir }}/{{ controller_name }}/jmxremote.access"
    mode: 0777

- name: "copy kafka truststore/keystore"
  when: kafka.protocol == 'SSL'
  copy:
    src:
      "{{openwhisk_home~'/ansible/roles/kafka/files/'~kafka.ssl.keystore.name}}"
    dest: "{{ controller.confdir }}/{{ controller_name }}"

- name: copy nginx certificate keystore
  when: controller.protocol == 'https'
  copy:
    src: files/{{ controller.ssl.keystore.name }}
    mode: 0666
    dest: "{{ controller.confdir }}/{{ controller_name }}"
  become: "{{ controller.dir.become }}"

- name: copy certificates
  when: controller.protocol == 'https'
  copy:
    src: "{{ openwhisk_home }}/ansible/roles/controller/files/{{ item }}"
    mode: 0666
    dest: "{{ controller.confdir }}/{{ controller_name }}"
  with_items:
    - "{{ controller.ssl.cert }}"
    - "{{ controller.ssl.key }}"
  become: "{{ controller.dir.become }}"

- name: check, that required databases exist
  include_tasks: "{{ openwhisk_home }}/ansible/tasks/db/checkDb.yml"
  vars:
    dbName: "{{ item }}"
    dbUser: "{{ db.credentials.controller.user }}"
    dbPass: "{{ db.credentials.controller.pass }}"
  with_items:
    - "{{ db.whisk.actions }}"
    - "{{ db.whisk.auth }}"
    - "{{ db.whisk.activations }}"

- name: prepare controller port
  set_fact:
    controller_port: "{{ controller.basePort + (controller_index | int) }}"
    ports_to_expose:
      - "{{ controller.basePort + (controller_index | int) }}:8080"

- name: expose additional ports if jmxremote is enabled
  when: jmx.enabled
  vars:
    jmx_remote_port: "{{ jmx.basePortController + (controller_index|int) }}"
    jmx_remote_rmi_port:
      "{{ jmx.rmiBasePortController + (controller_index|int) }}"
  set_fact:
    ports_to_expose: >-
      {{ ports_to_expose }} +
      [ '{{ jmx_remote_port }}:{{ jmx_remote_port }}' ] +
      [ '{{ jmx_remote_rmi_port }}:{{ jmx_remote_rmi_port }}' ]
    controller_args: >-
      {{ controller.arguments }}
      {{ jmx.jvmCommonArgs }}
      -Djava.rmi.server.hostname={{ inventory_hostname }}
      -Dcom.sun.management.jmxremote.rmi.port={{ jmx_remote_rmi_port }}
      -Dcom.sun.management.jmxremote.port={{ jmx_remote_port }}

- name: Load config from template
  set_fact:
      openwhisk_config: "{{ lookup('template', 'config.j2') | b64encode }}"
- import_tasks: env.yml
- name: check if coverage collection is enabled
  set_fact:
    coverage_enabled: false
  when: coverage_enabled is undefined

- name: ensure controller coverage directory is created with permissions
  file:
    path: "{{ coverage_logs_dir }}/controller/{{ item }}"
    state: directory
    mode: 0777
  with_items:
    - controller
    - common
  become: "{{ logs.dir.become }}"
  when: coverage_enabled

- name: extend controller volume for coverage
  set_fact:
    controller_volumes: "{{ controller_volumes|default({}) + [coverage_logs_dir+'/controller:/coverage']  }}"
  when: coverage_enabled

- name: include plugins
  include_tasks: "{{ item }}.yml"
  with_items: "{{ controller_plugins | default([]) }}"
  when: not lean

- name: lean controller setup
  include_tasks: "lean.yml"
  when: lean

- name: (re)start controller
  docker_container:
    name: "{{ controller_name }}"
    image:
      "{{docker_registry~docker.image.prefix}}/controller:{{ 'cov' if (coverage_enabled) else docker.image.tag }}"
    state: started
    recreate: true
    restart_policy: "{{ docker.restart.policy }}"
    hostname: "{{ controller_name }}"
    env: "{{ env }}"
    volumes: "{{ controller_volumes }}"
    ports: "{{ ports_to_expose }}"
    # userns_mode, pid_mode and privileged required when controller running in lean mode
    userns_mode: "{{ userns_mode | default('') }}"
    pid_mode: "{{ pid_mode | default('') }}"
    privileged: "{{ privileged | default('no') }}"
    command:
      /bin/sh -c
      "exec /init.sh {{ controller_index }}
      >> /logs/{{ controller_name }}_logs.log 2>&1"

- name: wait until the Controller in this host is up and running
  uri:
    url:
      "{{controller.protocol}}://{{ansible_host}}:{{controller_port}}/ping"
    validate_certs: "no"
    client_key:
      "{{ controller.confdir }}/{{ controller_name }}/{{ controller.ssl.key }}"
    client_cert:
      "{{ controller.confdir }}/{{ controller_name }}/{{ controller.ssl.cert }}"
  register: result
  until: result.status == 200
  retries: 12
  delay: 10
